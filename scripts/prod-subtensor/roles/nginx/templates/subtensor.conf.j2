# Subtensor WebSocket load balancer configuration
upstream subtensor_ws {
    {{ nginx_upstream_strategy | default('least_conn') }};
    keepalive {{ nginx_upstream_keepalive }};
    keepalive_requests {{ nginx_upstream_keepalive_requests }};
    keepalive_timeout {{ nginx_upstream_keepalive_timeout }};

{% for i in range(subtensor_replicas | int) %}
    server 127.0.0.1:{{ subtensor_ws_port_start | int + i }} max_fails={{ nginx_health_check_fails }} fail_timeout=30s;
{% endfor %}
}

# Rate limiting for RPC requests (use real IP from load balancer)
{% if nginx_behind_load_balancer | default(false) %}
limit_req_zone $http_x_forwarded_for zone=rpc_limit:10m rate=10r/s;
{% else %}
limit_req_zone $binary_remote_addr zone=rpc_limit:10m rate=10r/s;
{% endif %}

# WebSocket connection upgrade mapping
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

{% if nginx_behind_load_balancer | default(false) %}
# Trust forwarded headers from load balancer
set_real_ip_from 10.0.0.0/8;     # AWS VPC range
set_real_ip_from 172.16.0.0/12;  # AWS VPC range  
set_real_ip_from 192.168.0.0/16; # AWS VPC range
real_ip_header X-Forwarded-For;
real_ip_recursive on;
{% endif %}

{% if nginx_ssl_enabled | default(true) %}
server {
    listen 80;
    server_name {{ nginx_server_name | default(ansible_host + ' ' + (ansible_fqdn | default('_'))) }};

    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    location / {
        return 301 https://$server_name$request_uri;
    }
}
{% endif %}

server {
{% if nginx_ssl_enabled | default(true) %}
    listen 443 ssl http2;
    ssl_certificate /etc/nginx/ssl/subtensor_cert.pem;
    ssl_certificate_key /etc/nginx/ssl/subtensor_key.pem;
{% else %}
    listen 80;
{% endif %}

    server_name {{ nginx_server_name | default(ansible_host + ' ' + (ansible_fqdn | default('_'))) }};

{% for header in nginx_security_headers %}
    add_header {{ header }} always;
{% endfor %}

    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    location / {
        # Subtensor nodes only support WebSocket connections
        proxy_pass http://subtensor_ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        {% if nginx_behind_load_balancer | default(false) %}
        proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;
        {% else %}
        proxy_set_header X-Forwarded-Proto $scheme;
        {% endif %}

        # WebSocket-specific settings
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        proxy_buffering off;
        
        # Forward WebSocket headers
        proxy_set_header Sec-WebSocket-Extensions $http_sec_websocket_extensions;
        proxy_set_header Sec-WebSocket-Key $http_sec_websocket_key;
        proxy_set_header Sec-WebSocket-Version $http_sec_websocket_version;
        proxy_set_header Sec-WebSocket-Protocol $http_sec_websocket_protocol;

        # Rate limiting to prevent abuse
        limit_req zone=rpc_limit burst={{ nginx_rate_limit_burst }} nodelay;

        # Don't mark servers as failed for connection resets (common with WebSocket)
        proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
        proxy_next_upstream_timeout 10s;
        proxy_next_upstream_tries 3;
    }

    error_page 502 503 504 /50x.html;
    location = /50x.html {
        root /var/www/html;
        internal;
    }
}